using DragonFruit2.GeneratorSupport;

namespace DragonFruit2.Generators;

// The Cli uses a trick base on C# overload resolution behavior. Items in the current namespace have precedence over those in imported namespaces.
// When the user initially creates the app, importing DragonFruit2 supplies a CLI class for IntelliSense. When generation occurs, this call
// is replaced with the generated CLI. This design allows access to the RootArgsBuilder without complicating user code. In modern .NET, this 
// could also be done with a static interface method. However, old .NET Framework...
public class OutputCli
{
    internal static string GetSource(IEnumerable<CommandInfo> commandInfos)
    {
        var commandInfo = commandInfos
                .First(c => c.ParentCommandInfo == null);
        var sb = new StringBuilderWrapper();
        FileOpening(sb, commandInfo.CliNamespaceName, commandInfo.NamespaceName);
        sb.OpenNamespace(commandInfo.CliNamespaceName);

        OpenClass(commandInfo, sb);
        ParseArgsMethod(commandInfo, sb);
        TryParseArgsMethod(commandInfo, sb);
        //TryExecute(commandInfo, sb);

        sb.CloseClass();
        sb.CloseNamespace(commandInfo.CliNamespaceName);
        return sb.ToString();
    }

    private static void FileOpening(StringBuilderWrapper sb, string? cliNamespace, string? argsNamespace)
    {
        sb.AppendLines([
                       "// <auto-generated />",
                       "# nullable enable",
                       "",
                       "using DragonFruit2;"]);
        // This is necessary when the RootArgs is not in the same namespace as the call to `Cli.TryParse`, such as top-level statements 
        if (!string.IsNullOrEmpty(argsNamespace) && cliNamespace != argsNamespace)
        {
            sb.AppendLine($"using {argsNamespace};");
        }
    }

    internal static void OpenClass(CommandInfo commandInfo, StringBuilderWrapper sb)
    { 
        sb.AppendLines([
                "/// <summary>",
                $"""/// Auto-generated partial class that supplies the root ArgsBuilder type.""",
                "/// </summary>",
                $"{commandInfo.ArgsAccessibility} class Cli"]);
        sb.OpenCurly();
    }

    private static void ParseArgsMethod(CommandInfo rootCommandInfo, StringBuilderWrapper sb)
    {
        var rootName = rootCommandInfo.Name;

        sb.XmlSummary("Parses CLI arguments to fill the specified args type.<br/>This method is generated specific to the type argument.<br/>You may need to build after editing.");
        sb.XmlRemarks("The args class specified as the type argument must be public.");
        sb.XmlTypeParam("TRootArgs", "The type containing the CLI definition.");
        sb.XmlParam("args", "Optionaly pass the commandline args, using the keyword `args`. If not passed, they will be retrieved for you.");

        sb.OpenMethod($"public static Result<{rootName}> ParseArgs<TRootArgs>(string[]? args = null)",
            constraints: $"TRootArgs : {rootName}, IArgs<TRootArgs>");
        sb.AppendLine($"return new Builder<{rootName}, {rootName}.{rootName}ArgsBuilder>(args).ParseArgs(args);");
        sb.CloseMethod();
    }

    private static void TryParseArgsMethod(CommandInfo rootCommandInfo, StringBuilderWrapper sb)
    {
        var rootName = rootCommandInfo.Name;

        sb.XmlSummary("Attempts to parses CLI arguments and fill the specified args type.<br/>This method is generated specific to the type argument.<br/>You may need to build after editing.");
        sb.XmlRemarks("The args class specified as the type argument must be public.");
        sb.XmlTypeParam("TRootArgs", "The type containing the CLI definition.");
        sb.XmlParam("result", "An out parameter that contains an instance of the requested class and supporting data, such as diagnostics, a suggested CLI return value, etc.");
        sb.XmlParam("args", "Optionaly pass the commandline args, using the keyword `args`. If not passed, they will be retrieved for you.");
        sb.XmlException("InvalidOperationException", "To be implemented soon.");

        sb.OpenMethod($"public static bool TryParseArgs<TRootArgs>(out Result<{rootName}> result, string[]? args = null)",
            constraints: $"TRootArgs : {rootName}, IArgs<TRootArgs>");

        sb.AppendLine($"result = ParseArgs<TRootArgs>(args);");
        sb.Return("result.IsValid");
        sb.CloseMethod();
    }
}

