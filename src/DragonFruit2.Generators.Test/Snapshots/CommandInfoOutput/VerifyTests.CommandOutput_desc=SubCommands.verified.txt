// <auto-generated />
# nullable enable

using DragonFruit2;
using DragonFruit2.Validators;
using System.CommandLine;
using System.Diagnostics.CodeAnalysis;

namespace MyNamespace
{
    /// <summary>
    /// Auto-generated partial class for building CLI commands for <see cref="MyArgs"/>" and creating a new MyArgs instance from a <see cref="System.CommandLine.ParseResult" />.
    /// </summary>
    public partial class MyArgs : IArgs<MyArgs>
    {


        public MyArgs()
        {
        }
        [SetsRequiredMembers()]
        protected MyArgs(DataValue<string>? nameDataValue)
            : this()
        {
            if (ValueIsAvailable(nameDataValue)) Name = nameDataValue.Value;

            static bool ValueIsAvailable<T>([NotNullWhen(true)] DataValue<T>? dataValue)
            {
                return dataValue switch
                {
                    null => false,
                    { IsSet: true } => true,
                    _ => false
                };
            }
        }

        public IEnumerable<ValidationFailure> Validate()
        {
            var failures = new List<ValidationFailure>();
            InitializeValidators();


            return failures;
        }

        private void InitializeValidators()
        {
        }

        static partial void RegisterCustomDefaults(Builder<> builder, DefaultDataProvider<> defaultDataProvider);

        public static ArgsBuilder<> GetArgsBuilder(Builder<> builder)
        {
            return new MyArgs.MyArgsArgsBuilder();
        }

        /// <summary>
        ///  This static builder supplies the CLI declaration and filling the Result and return instance.
        /// </summary>
        /// <remarks>
        ///  The first type argument of the base is the Args type this builder creates, and the second is the root Args type. This means the two type arguments are the same for the root ArgsBuilder, but will differ for subcommand ArgsBuilders.
        /// </remarks>
        internal class MyArgsArgsBuilder : ArgsBuilder<>
        {

            public override void Initialize(Builder<> builder)
            {
                InitializeCli(builder, builder.GetDataProvider<CliDataProvider<>>());
                InitializeDefaults(builder, builder.GetDataProvider<DefaultDataProvider<>>());
            }

            public override Command InitializeCli(Builder<> builder, CliDataProvider<>? cliDataProvider)
            {
                var cmd = new System.CommandLine.RootCommand("my")
                {
                    Description = null,
                };

                var nameOption = new Option<string>("--name")
                {
                    Description = null,
                    Required = true,
                    Recursive=true
                };
                cliDataProvider.AddNameLookup((typeof(MyArgs), nameof(Name)), nameOption);
                cmd.Add(nameOption);

                var morningGreetingArgsCommand = MorningGreetingArgs.GetArgsBuilder(builder).InitializeCli(builder, cliDataProvider);
                cmd.Add(morningGreetingArgsCommand);

                var eveningGreetingArgsCommand = EveningGreetingArgs.GetArgsBuilder(builder).InitializeCli(builder, cliDataProvider);
                cmd.Add(eveningGreetingArgsCommand);

                cmd.SetAction(p => { ArgsBuilderCache<>.ActiveArgsBuilder = this; return ; });
                return cmd;
            }

            public void InitializeDefaults(Builder<> builder, DefaultDataProvider<>? defaultDataProvider)
            {
                if (defaultDataProvider is null) return;
                // TODO: Register defaults based on attributes, initializer, and the RegisterDefault calls
                RegisterCustomDefaults(builder, defaultDataProvider);
            }


            protected override IEnumerable<ValidationFailure> CheckRequiredValues(DataValues dataValues)
            {
                if (dataValues is not MyArgsDataValues typedDataValues)
                {
                    throw new InvalidOperationException("Internal error: passed incorrect data values");
                }
                var requiredFailures = new List<ValidationFailure?>();
                AddRequiredFailureIfNeeded<string>(requiredFailures, !typedDataValues.Name.IsSet, nameof(Name));
                return requiredFailures
                          .Where(x => x is not null)
                          .Select(x => x!);
            }

            protected override DataValues CreateDataValues()
            {
                return new MyArgsDataValues();
            }

            protected override  CreateInstance(DataValues dataValues)
            {
                if (dataValues is not MyArgsDataValues typedDataValues)
                {
                    throw new InvalidOperationException("Internal error: passed incorrect data values");
                }

                return new MyArgs(typedDataValues.Name);            }
        }

        public class MyArgsDataValues : DataValues
        {

            public override void SetDataValues(DataProvider dataProvider)
            {
                dataProvider.SetDataValue((typeof(MyArgs), nameof(Name)), Name);
            }

            private Type argsType = typeof(MyArgs);
            public DataValue<string> Name { get; } = DataValue<string>.Create(nameof(Name), typeof(MyArgs));
        }
    }
}
